<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Retro Emoji Snake</title>
  <style>
    :root {
      --bg: #0e0f13;
      --panel: #151823;
      --grid: #1f2332;
      --snake: #4de26e;
      --snake-dark: #34b454;
      --snake-eye: #f8fafc;
      --fruit-shadow: rgba(0,0,0,.35);
      --accent: #7df9ff;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 50% 30%, #101423 0%, #0c0f18 60%, #07080d 100%);
      color: #cbd5e1;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      display: grid;
      place-items: center;
      padding: 16px;
    }

    .frame {
      width: min(92vw, 640px);
      background: linear-gradient(180deg, #111522, #0c0f1a);
      border: 2px solid #2a2f45;
      border-radius: 16px;
      box-shadow: 0 16px 40px rgba(0,0,0,.6), inset 0 0 0 1px rgba(255,255,255,.06);
      overflow: hidden;
    }

    header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 14px; gap: 8px;
      background: linear-gradient(180deg, #14192a, #0f1322);
      border-bottom: 1px solid #262b43;
      text-shadow: 0 1px 0 rgba(0,0,0,.6);
    }
    header .title { font-weight: 800; letter-spacing: .5px; color: var(--accent); }
    header .stats { display: flex; gap: 16px; align-items: center; }
    .stat { display: flex; align-items: center; gap: 6px; }
    .stat b { color: #e2e8f0; }

    .screen {
      position: relative;
      aspect-ratio: 1 / 1; /* will be square */
      background: #0b0e17;
      display: grid;
      place-items: center;
    }

    /* Canvas is scaled up with pixelated look */
    canvas {
      image-rendering: pixelated;
      width: 92%;
      height: 92%;
      max-width: 560px;
      max-height: 560px;
      box-shadow: 0 0 0 2px #20263c, 0 12px 28px rgba(0,0,0,.5);
      border-radius: 10px;
      background: var(--panel);
    }

    /* Subtle CRT scanlines */
    .scanlines::after {
      content: "";
      position: absolute; inset: 0; pointer-events: none;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.03) 0px,
        rgba(255,255,255,.03) 2px,
        transparent 2px,
        transparent 4px
      );
      mix-blend-mode: overlay;
      opacity: .5;
      border-radius: 10px;
    }

    .controls {
      display: grid; gap: 8px; padding: 12px; background: #0f1424; border-top: 1px solid #262b43;
      grid-template-columns: 1fr 1fr 1fr; align-items: center;
    }

    .btn {
      appearance: none; border: 1px solid #2a2f45; background: #12172a; color: #e2e8f0;
      padding: 10px 12px; border-radius: 10px; cursor: pointer; font-weight: 700;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.05), 0 6px 14px rgba(0,0,0,.35);
      transition: transform .05s ease, filter .15s ease;
    }
    .btn:hover { filter: brightness(1.12); }
    .btn:active { transform: translateY(1px); }

    .select, .toggle {
      display: flex; align-items: center; gap: 8px; justify-content: center;
      color: #cbd5e1; font-weight: 700;
    }
    select, input[type="checkbox"] { accent-color: var(--accent); }

    .dpad { display: grid; grid-template-columns: repeat(3, 56px); grid-template-rows: repeat(3, 56px); gap: 6px; justify-content: end; }
    .dpad .padbtn {
      display: grid; place-items: center; background: #141a2e; border: 1px solid #2a2f45; border-radius: 10px; cursor: pointer; font-size: 20px; user-select: none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.05);
    }
    .dpad .padbtn:active { transform: translateY(1px); }

    /* Game over overlay */
    .overlay {
      position: absolute; inset: 0; display: none; place-items: center; background: rgba(5,8,14,.6); backdrop-filter: blur(2px);
      border-radius: 10px;
    }
    .overlay.show { display: grid; }
    .card {
      background: #0e1426; border: 1px solid #2a2f45; padding: 16px; border-radius: 12px; text-align: center;
      box-shadow: 0 10px 22px rgba(0,0,0,.5);
    }
    .card h2 { margin: 6px 0 2px; color: #e2e8f0; }
    .card p { margin: 4px 0 12px; color: #cbd5e1; }

    /* Small help text */
    .help { font-size: 12px; opacity: .75; text-align: center; padding: 6px 0 4px; }
  </style>
</head>
<body>
  <div class="frame">
    <header>
      <div class="title">üêç Retro Emoji Snake</div>
      <div class="stats">
        <div class="stat" title="Score"><span>üèÜ</span> <b id="score">0</b></div>
        <div class="stat" title="High Score"><span>üëë</span> <b id="high">0</b></div>
        <div class="stat" title="Speed"><span>‚ö°</span> <b id="speedLabel">Normal</b></div>
      </div>
    </header>

    <div class="screen scanlines">
      <canvas id="game" width="320" height="320"></canvas>
      <div id="overlay" class="overlay">
        <div class="card">
          <div style="font-size:34px">üí• Game Over!</div>
          <h2><span id="finalScore">0</span> pts</h2>
          <p>Press <b>R</b> to restart or tap the button.</p>
          <button class="btn" id="againBtn">üîÑ Play Again</button>
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" id="pauseBtn">‚è∏Ô∏è Pause</button>
      <div class="select">
        <label for="speed">Speed</label>
        <select id="speed">
          <option value="140">Chill</option>
          <option value="110" selected>Normal</option>
          <option value="85">Fast</option>
          <option value="65">Turbo</option>
        </select>
      </div>
      <div class="toggle">
        <label for="wrap">Wrap</label>
        <input id="wrap" type="checkbox" />
      </div>

      <div class="help" style="grid-column: 1 / -1">Use ‚¨ÖÔ∏è‚¨ÜÔ∏è‚û°Ô∏è‚¨áÔ∏è or WASD. Press <b>Space</b> to pause. <b>R</b> to restart. Swipe or use the D‚Äëpad on mobile.</div>

      <div style="grid-column: 1 / -1; display: grid; grid-template-columns: 1fr auto; align-items: center;">
        <div style="opacity:.7; font-size:12px;">Fruit: üçé üçí üçá üçì üçä üçã üçâ ü´ê</div>
        <div class="dpad" id="dpad" aria-label="D-Pad">
          <div></div>
          <div class="padbtn" data-dir="up">‚¨ÜÔ∏è</div>
          <div></div>
          <div class="padbtn" data-dir="left">‚¨ÖÔ∏è</div>
          <div></div>
          <div class="padbtn" data-dir="right">‚û°Ô∏è</div>
          <div></div>
          <div class="padbtn" data-dir="down">‚¨áÔ∏è</div>
          <div></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- Game constants ---
    const TILE = 16;           // logical pixel size per grid cell
    const GRID = 20;           // 20x20 grid
    const FRUITS = ["üçé","üçè","üçí","üçá","üçì","üçä","üçã","üçâ","ü´ê"]; // emoji fruits

    // Canvas setup
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = GRID * TILE;
    canvas.height = GRID * TILE;

    // UI elements
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    const speedSel = document.getElementById('speed');
    const speedLabel = document.getElementById('speedLabel');
    const pauseBtn = document.getElementById('pauseBtn');
    const overlay = document.getElementById('overlay');
    const finalScore = document.getElementById('finalScore');
    const againBtn = document.getElementById('againBtn');
    const wrapToggle = document.getElementById('wrap');

    // Game state
    let snake, dir, pendingDir, fruit, fruitEmoji, score, high, stepMs, timer, running, wrap;

    function init() {
      snake = [ {x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10} ];
      dir = {x: 1, y: 0};
      pendingDir = {x: 1, y: 0};
      score = 0;
      scoreEl.textContent = score;
      stepMs = parseInt(speedSel.value, 10);
      speedLabel.textContent = speedSel.options[speedSel.selectedIndex].text;
      wrap = wrapToggle.checked;
      fruit = randFreeCell();
      fruitEmoji = FRUITS[(Math.random()*FRUITS.length)|0];
      high = parseInt(localStorage.getItem('retro-snake-high')||'0', 10);
      highEl.textContent = high;
      running = true;
      overlay.classList.remove('show');
      clearInterval(timer);
      timer = setInterval(tick, stepMs);
      draw();
    }

    // Utility
    function cellsEqual(a,b){ return a.x===b.x && a.y===b.y; }
    function inBounds(p){ return p.x>=0 && p.x<GRID && p.y>=0 && p.y<GRID; }
    function randFreeCell(){
      let p;
      do {
        p = { x: (Math.random()*GRID)|0, y: (Math.random()*GRID)|0 };
      } while (snake.some(s=>cellsEqual(s,p)));
      return p;
    }

    // Game tick
    function tick(){
      if (!running) return;
      // Apply pending direction (prevents reversing into itself in same frame)
      if ((pendingDir.x !== -dir.x) || (pendingDir.y !== -dir.y)) {
        dir = pendingDir;
      }

      // Compute next head
      let head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

      if (wrap) {
        head.x = (head.x + GRID) % GRID;
        head.y = (head.y + GRID) % GRID;
      }

      // Collisions
      if (!wrap && !inBounds(head)) {
        return gameOver();
      }
      if (snake.some((s,i)=> i>0 && cellsEqual(s, head))) {
        return gameOver();
      }

      // Move
      snake.unshift(head);

      // Eat fruit?
      if (cellsEqual(head, fruit)) {
        score += 10; // each fruit worth 10
        scoreEl.textContent = score;
        fruit = randFreeCell();
        fruitEmoji = FRUITS[(Math.random()*FRUITS.length)|0];
        // Slight speed up every 5 fruits for tension
        if (score % 50 === 0 && stepMs > 50) {
          stepMs -= 3;
          clearInterval(timer);
          timer = setInterval(tick, stepMs);
        }
      } else {
        snake.pop(); // no grow this turn
      }

      draw();
    }

    function gameOver(){
      running = false;
      clearInterval(timer);
      finalScore.textContent = score;
      overlay.classList.add('show');
      if (score > high) {
        high = score;
        localStorage.setItem('retro-snake-high', String(high));
        highEl.textContent = high;
      }
    }

    // Draw everything
    function draw(){
      // Clear
      ctx.fillStyle = '#0b0f1d';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Grid background
      ctx.strokeStyle = '#1b2134';
      ctx.lineWidth = 1;
      for (let i=0;i<=GRID;i++){
        // vertical
        ctx.beginPath();
        ctx.moveTo(i*TILE + .5, 0); ctx.lineTo(i*TILE + .5, GRID*TILE); ctx.stroke();
        // horizontal
        ctx.beginPath();
        ctx.moveTo(0, i*TILE + .5); ctx.lineTo(GRID*TILE, i*TILE + .5); ctx.stroke();
      }

      // Fruit (emoji)
      ctx.font = `${Math.floor(TILE*0.9)}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const fx = fruit.x*TILE + TILE/2;
      const fy = fruit.y*TILE + TILE/2 + 1; // slight vertical tweak
      // drop shadow for fruit to pop
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,.35)';
      ctx.shadowBlur = 6; ctx.shadowOffsetY = 2;
      ctx.fillText(fruitEmoji, fx, fy);
      ctx.restore();

      // Snake segments
      for (let i=snake.length-1;i>=0;i--){
        const s = snake[i];
        const x = s.x*TILE, y = s.y*TILE;
        ctx.fillStyle = i===0 ? 'var(--snake-dark)' : 'var(--snake)';
        ctx.fillStyle = i===0 ? '#34b454' : '#4de26e';
        ctx.fillRect(x+1, y+1, TILE-2, TILE-2);
        // segment bevel
        ctx.fillStyle = 'rgba(255,255,255,.06)';
        ctx.fillRect(x+1, y+1, TILE-2, 2);
        ctx.fillStyle = 'rgba(0,0,0,.12)';
        ctx.fillRect(x+1, y+TILE-3, TILE-2, 2);
      }

      // Head eyes
      const h = snake[0];
      if (h){
        const ex = h.x*TILE; const ey = h.y*TILE;
        const left = dir.x===1 || (dir.x===0 && dir.y!==0) ? 3 : (dir.x===-1 ? 9 : 3);
        const top = dir.y===1 ? 9 : (dir.y===-1 ? 3 : 5);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(ex+left, ey+top, 3, 3);
        ctx.fillRect(ex+left+6, ey+top, 3, 3);
        ctx.fillStyle = '#0b0f1d';
        ctx.fillRect(ex+left+1, ey+top+1, 1, 1);
        ctx.fillRect(ex+left+7, ey+top+1, 1, 1);
      }
    }

    // Input handling
    function setDir(nx, ny){
      // prevent immediate 180¬∞ turn when length > 1
      if (snake.length > 1 && nx === -dir.x && ny === -dir.y) return;
      pendingDir = {x: nx, y: ny};
    }

    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if (["arrowleft","a"].includes(k)) { setDir(-1,0); e.preventDefault(); }
      else if (["arrowright","d"].includes(k)) { setDir(1,0); e.preventDefault(); }
      else if (["arrowup","w"].includes(k)) { setDir(0,-1); e.preventDefault(); }
      else if (["arrowdown","s"].includes(k)) { setDir(0,1); e.preventDefault(); }
      else if (k === ' ') { togglePause(); e.preventDefault(); }
      else if (k === 'r') { restart(); }
    });

    // Touch swipe controls
    let touchStart = null;
    canvas.addEventListener('touchstart', (e)=>{ const t=e.touches[0]; touchStart={x:t.clientX,y:t.clientY}; });
    canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); }, {passive:false});
    canvas.addEventListener('touchend', (e)=>{
      if (!touchStart) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStart.x;
      const dy = t.clientY - touchStart.y;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx>10) setDir(1,0); else if (dx<-10) setDir(-1,0);
      } else {
        if (dy>10) setDir(0,1); else if (dy<-10) setDir(0,-1);
      }
      touchStart=null;
    });

    // D‚Äëpad clicks
    document.getElementById('dpad').addEventListener('click', (e)=>{
      const btn = e.target.closest('.padbtn'); if (!btn) return;
      const d = btn.getAttribute('data-dir');
      if (d==='up') setDir(0,-1); else if (d==='down') setDir(0,1); else if (d==='left') setDir(-1,0); else if (d==='right') setDir(1,0);
    });

    // UI hookups
    pauseBtn.addEventListener('click', togglePause);
    speedSel.addEventListener('change', ()=>{ stepMs = parseInt(speedSel.value,10); speedLabel.textContent = speedSel.options[speedSel.selectedIndex].text; if (running){ clearInterval(timer); timer = setInterval(tick, stepMs); }});
    againBtn.addEventListener('click', restart);
    wrapToggle.addEventListener('change', ()=>{ wrap = wrapToggle.checked; });

    function togglePause(){
      running = !running;
      if (running){
        pauseBtn.textContent = '‚è∏Ô∏è Pause';
      } else {
        pauseBtn.textContent = '‚ñ∂Ô∏è Resume';
      }
    }
    function restart(){ init(); }

    // Start the game
    init();
  </script>
</body>
</html>
